---
title: "Tarea 1"
author: "Cuéllar, E. Tapia, J. Maciel, J. Saldaña, R. Miranda, G"
date: "15/Oct/2021"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
1.- Grafique los datos. Describa lo que observe de su información (varianza contante o no
constante, tendencia, ciclos estacionales, periodicidad de los ciclos).

```{r,echo=FALSE, message=FALSE}
#Cargamos las librerías
library(timeSeries)
library(forecast)
library(tseries)
library(astsa)
library(nortest)
library(TSA)
library(ggplot2)
library(lmtest)
#Leemos los datos
#Probando
# Prueba 2
Data<-read.table("https://robjhyndman.com/tsdldata/data/fancy.dat", 
           header=F, skip=0)
#Los pasamos a series de tiempo
Serie<-ts(data=Data,start=c(1987,01),end=c(1993,12),frequency=12)
```

## Gráfica de la serie de tiempo

```{r, echo=FALSE, message=FALSE}
ts.plot(Serie)
```

## Varianza

Podemos observar una varianza creciente conforme pasa el tiempo, teniendo primero
un ligero aumento de 1987 a 1990 de manera lineal, después parece que se mantene constante de 1990 a 1991 
para posteriormente crecer demasiado de 1991 a 1994 Es decir, no es constante la varianza.
Lo que hace que se dispare es la temporada alta vacacional (Al parecer, en noviembre
y diciembre, ya que analizamos una playa en Australia, donde el verano comienza en diciembre).
Podemos comprobarlo con un bp test:
```{r}
# Ho: (Homocedasticidad)  vs  H1: La varianza no es constate (Heterocedasticidad)
t1 = seq(1987+0/12, 1993+11/12, by = 1 / 12)
bptest(Serie ~t1)
```
Inclusive podemos ver de una vez que no es estacionaria tanto con el test de Dickey-Fuller 
como con el de Phillips:
```{r}
# Ho: La serie no es estacionaria vs. H1: La serie es estacionaria
adf.test(Serie)
#Por lo tanto: 

# Ho: La serie es estacionaria vs. H1: La serie no es estacionaria
kpss.test(Serie)
```

## Tendencia

La tendencia parece ser en general creciente, repitiendo casi el mismo patrón que 
la varianza: Es creciente de manera ligera (lineal, con pendiente pequeña) de 1987
a 1990, para después decrecer un poco de 1990 a 1991, sin embargo crece de manera 
cuadrática, al parecer, de 1991 a 1994.


## Ciclos estacionales

Dado que estamos analizando una base de datos de ventas mensuales de una tienda de souvenirs 
en una playa en Asutralia, hace todo el sentido del mundo que tenga un ciclo ya que
tanto en las ventas como visitas a sitios vacacionales hay una fuerte dependencia 
en los meses del año. Esto lo confirmamos con la gráfica, donde se observa un
ciclo estacional bastante claro.

## Periodicidad de los ciclos

Complementando el comentario del punto anterior, en la gráfica observamos que
el ciclo es anual. De enero a febrero (o los primeros meses del año)parece crecer ligeramente, 
depués baja un poco para crecer de manera ligera nuevamente, pero al llegar lo que parece ser 
noviembre y diciembre (o los últimos meses del año)crece exageradamente; posteriormente 
baja de diciembre a enero y se repite el ciclo.


2.-Si la base presenta datos faltantes NA. Use algún método de imputación de la paquetería
imputeTS.

No hay ningún NA, como podemos observar

```{r,echo=FALSE}
sum(is.na(Serie))
```
Por lo que no es necesario aplicar ningún método de imputación

3.- Use distintos métodos de descomposición de las series para obtener sus componentes
(tendencia y ciclos estacionales), en específico use los siguientes:

(a) Ajuste de curvas (modelos deterministas o de regresión).
Realice un pronóstico de 3 años futuros.

Primero realizareos una transformación con el logarítmo para estabilizar la varianza

```{r}
Serie_ln<-(log(Serie))
ts.plot(Serie_ln)
```

Al parecer, la varianza ya se estabilizó considerablemente (De manera gráfica).
¡Comprobémoslo con un bp test!
```{r}
bptest(Serie_ln~t1)
```

¡Se pudo estabilizar! Pero, si tomamos la raíz, quizás podamos estabilizarla
un poco más. comprobémoslo:
```{r}
Serie_ln<-sqrt(log(Serie))
ts.plot(Serie_ln)
bptest(Serie_ln~t1)
```

Nos quedaremos entonces con la raíz del logarítmo, puesto que presenta un 
p-value mayor.


Como la tendencia parece seguir un comportamiento de un polinomio de grado 2,
intentaremos ajustarle una curva con dicho polinomio

```{r}
M <- factor(cycle(Serie_ln))
t = time(Serie_ln)-1987 
regresion_1= lm(Serie_ln ~ 0+ t+M,  na.action=NULL)
summary(regresion_1)
par(mfrow=c(1,2))
plot(Serie_ln, type="o",col='darkorange1')
lines(fitted(regresion_1), col='black')
```

Observamos que todos los valores,tienen un p-value menor
a $0.05$. Entonces, quitando el efecto de ciclos estacionales, sigue una tendencia
lineal.

$\mathbb{E}[X_t]= 0.26872t+M$

Donde M es la parte del ciclo estacional.

Ajustamos:


```{r regresion_1}
tnew = 7 + seq(0,3,length.out=37)
Mnew = factor(c((1:12),(1:12),(1:12),1))
pred1<- predict(regresion_1, newdata=list(t=tnew, M=Mnew), interval="prediction")
par(mfrow=c(1,2))
ts.plot(Serie_ln, xlim=c(1987,1998))
lines(1987+tnew,(pred1[,1]), lty=1,col=2)
lines(1987+tnew,(pred1[,2]), lty=2,col=4)
lines(1987+tnew,(pred1[,3]), lty=2,col=4)
ts.plot(Serie_ln, xlim=c(1987,1998))
lines(1987+tnew,exp(pred1[,1]**2), lty=1,col=2)
lines(1987+tnew,exp(pred1[,2]**2), lty=2,col=4)
lines(1987+tnew,exp(pred1[,3]**2), lty=2,col=4)
```

Ahora comprobemos los supuestos de regresión

```{r}
tsdisplay(regresion_1$res)
qqnorm(regresion_1$res)
qqline(regresion_1$res)
ad.test(regresion_1$res)

bptest(regresion_1)
```

Pasamos los tests de Normalidad y homocedasticidad.

(b) Filtros lineales o suavizamientos exponenciales.
Realice un pronóstico de 3 años futuros.

```{r}

####FILTROS LINEALES#####

#Tendencia y ciclos 
Xt = Serie_ln
##Frecuencia?
p = periodogram(Xt, main="Periodograma", col=4) # Obtenemos el periodograma

names(p)

# Ordenamos de mayor a menor las estimaciones del periodograma.
spec = sort(p$spec, decreasing = TRUE) 
(spec = spec[1:5]) # Nos quedamos con los coeficientes de mayor frecuencia
i = match(spec, p$spec) # Buscamos sus indices en el periodograma
d = p$freq # Frecuencias del periodograma
d = d[i] # Nos quedamos con las frecuencias que nos interesan
###########
cbind(spec,d,i)#
d = 1 / d # Obtenemos los parametros para utilizar en promedios moviles.
d = floor(d) #
(d = sort(d))
# Quitamos los periodos mas grandes
d = d[-length(d)] 
d = d[-length(d)] 
d #Posibles periodos del ciclo 

# Colores para graficar
col = c("lightsalmon", "purple", "cyan3")
plot(Serie_ln, lwd = 3, xlab = "Tiempo", col = "black",
     main = "Serie con varianza Homoscedastica",
     ylab = "Numero", col.main = "cornflowerblue")
library(dplyr)
t1 = seq(1987+0/12, 1993+11/12, by = 1 / 12)
for (i in 1:3) {
  lines(t1, stats::filter(Serie_ln, rep(1 / d[i], d[i])), col = col[i], 
        lwd = 3)
}
legend("bottomright", col = col, lty = 2, lwd = 2, bty = "n",
       legend = c(paste("d = ", d[1]), paste("d = ", d[2]),
                  paste("d = ", d[3])), cex = 1)

# Notemos que podemos aproximar la tendencia con d = 12.

tendencia = stats::filter(Serie_ln, rep(1 / 12, 12))
plot(Serie_ln, lwd = 3, xlab = "Tiempo", col = "black",
     main = "Tendencia",
     ylab = "Numero", col.main = "cornflowerblue")
lines(tendencia, col = "plum2", lwd = 4)
legend("bottomright", col = "plum2", lty = 1, lwd = 2, bty = "n",
       legend = "Tendencia", cex = 1)
```


Utilizaremos promedios móviles para filtro lineles. Con Holt Winters trabajaremos el 
suavizamiento exponencial y el pronóstico.

## Promedios móviles

```{r}
xt = Serie_ln
mj = rep(NA,6)
for(j in 1:6){
	mj[j] = sum(xt[12*(j-1)+1:12])/12
}
sk = rep(NA,12)
for(k in 1:12){
	sk[k] = sum(xt[(0:5)*12+k]-mj)/6
}
aleatorio = xt-rep(mj,each=12)-rep(sk,times=6)
compon = rep(mj,each=12)+rep(sk,times=6)
compon = ts(compon, start=start(xt), frequency=12)

par(mfrow=c(1,2))
plot(Serie,main='Serie original')
lines(exp(compon**2),col="deeppink1")
plot(aleatorio,main='aleatorio')

```

## Suavizamiento exponencial 
Para esta parte usaremos el método de Holt-Winter que pertenece a los métodos de 
suavizamiento exponencial
```{r}
xt.hw = HoltWinters(Serie_ln, seasonal="additive")
plot(xt.hw)
xt.predict = predict(xt.hw, n.ahead=3*12)
ts.plot(Serie_ln, xt.predict, lty=1:3)
```

(c) Diferencias.

```{r}
yt= Serie_ln
zt= diff(yt)
zt= diff(diff(yt),4)
par(mfrow=c(3,1))
plot(zt)
acf(zt)
pacf(zt)
```

4.- Describa brevemente en qué consisten los métodos de suavizado exponencial (exponential
smoothing) para las series de tiempo y el método de Holt Winters.

En las notas del curso se nos describe de manera breve y concisa cómo es que funcionan:

La selección del método se basa generalmente en el reconocimiento de la tendencia y estacionalidad, 
así como en la forma en que estos entran en el método de suavizamiento, como aditiva o 
multiplicativa.
Generalmente se usa el promedio para pronosticar si todos los pronósticos futuros son iguales
a un promedio simple de los datos obervados, puede ser sensato asignar mayor peso a las obser
vaciones más recientes que a las del pasado más distante. En palabras más simples podemos definir
lo de la siguiente manera: 
"Son básicamente promedios ponderados de observaciones pasadas, con los pesos 
decayendo exponencialmente a medida que las observaciones "envejecen"(...)". 

Por otro lado, el método de Holt Winters habla de la forma del componente para el método aditivo y
el método multiplicativo.

Más especificamente, el método de Holt Winters amplía el suavizado simple exponencial
para permitir además el pronóstico de datos con tendencia y capturar la estacionalidad, además
la ecuación estacional muestra un promedio ponderado entre el índice estacional actual y el índice 
estacional pero un año atrás. 

El método multiplicativo es similar al aditivo. El método de multiplicativo de Holt-Winters también 
calcula valores suavizados simple exponencialmente para el nivel, tendencia y ajuste estacional para 
la previsión. Este método multiplica la previsión con tendencia por la estacionalidad, lo que produce
la previsión de multiplicativo de Holt-Winters.

5.- Use el método de Holt Winters para el ajuste de la curva y predicción de los datos de 3
años futuros.

Esto se hizo en el 3b), con el siguiente código:

```{r}
xt.hw = HoltWinters(Serie_ln, seasonal="additive")
plot(xt.hw)
xt.predict = predict(xt.hw, n.ahead=3*12)
ts.plot(Serie_ln, xt.predict, lty=1:3)
```